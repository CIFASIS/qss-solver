/*****************************************************************************

 This file is part of QSS Solver.

 QSS Solver is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 QSS Solver is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with QSS Solver.  If not, see <http://www.gnu.org/licenses/>.

 ******************************************************************************/

#include <getopt.h>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <list>
#include <string>

#include "ast/ast_types.h"
#include "ast/stored_definition.h"
#include "generator/files.h"
#include "generator/generator.h"
#include "generator/generator_types.h"
#include "ir/mmo_ir.h"
#include "ir/mmo_model_checker.h"
#include "ir/mmo_settings.h"
#include "ir/mmo_types.h"
#include "ir/mmo_util.h"
#include "parser/parse.h"
#include "util/compile_flags.h"
#include "util/error.h"
#include "util/symbol_table.h"
#include "util/util.h"
#include "util/util_types.h"

using namespace std;

void usage()
{
  cout << "Usage mmoc [options] file" << endl;
  cout << "Compile MicroModelica files and generate a C file that implements a model suitable for the Stand--Alone QSS solver." << endl;
  cout << endl;
  cout << "-d <flag>, --debug <flag>" << endl;
  cout << "                Sets the simulation debug <flag>, the debug information is written in the log file generated " << endl;
  cout << "                by the Stand--Alone QSS solver and is an OR combination of the following possibilities: " << endl;
  cout << "                    SD_DBG_All: Enable all the debug flags" << endl;
  cout << "                    SD_DBG_Dt: Log dt parameter changes in parallel simulations" << endl;
  cout << "                    SD_DBG_ExternalEvent: Output step information for each external event in parallel simulations" << endl;
  cout << "                    SD_DBG_InitValues: Output the simulation initialization, including initial state and state derivatives values" << endl;
  cout << "                    SD_DBG_Memory: Output memory footprint" << endl;
  cout << "                    SD_DBG_Synchronize: Output synchronization information in parallel simulations" << endl;
  cout << "                    SD_DBG_StepInfo: Output for each simulation step:" << endl;
  cout << "                       ** The step time" << endl;
  cout << "                       ** The type and index of the variable that changes" << endl;
  cout << "                    SD_DBG_VarChanges: Output the model's state variable changes and the number of handler executions" << endl;
  cout << "                                       for each event defined in the model" << endl;
  cout << "                    SD_DBG_WaitFor: Output synchronization information in parallel simulations" << endl;
  cout << "                    SD_DBG_Weights: Save the output values generated by the SD_DBG_VarChanges into a binary file" << endl;
  cout << "-e, --external-structure-file <file>" << endl;
  cout << "                Read model incidence matrices from <file>." << endl;
  cout << "-f, --force " << endl;
  cout << "                Force external package compilation." << endl;
  cout << "-h, --help      Display this information and exit" << endl;
  cout << "-i <path>, --include <path>" << endl;
  cout << "                Include <path> in the library path search.          " << endl;
  cout << "-o <file>, --output <file>" << endl;
  cout << "                Sets the output to <file>" << endl;
  cout << "-O, --optimize" << endl;
  cout << "                Try to avoid the calculation of the next time of change for influenced variables in QSS algorithms (experimental)" << endl;
  cout << "-p, --parallel" << endl;
  cout << "                Generate code for parallel simulation." << endl;
  cout << "-s, --settings-only" << endl;
  cout << "                Generate only the settings (.ini) file." << endl;
  cout << "-v, --version   Display version information and exit" << endl;
  cout << endl;
  cout << "Report bugs to: joaquin.f.fernandez@gmail.com" << endl;
  cout << "MicroModelica C Compiler home page: https://sourceforge.net/p/qssengine/" << endl;
}

void version()
{
  cout << "MicroModelica C Compiler 3.1" << endl;
  cout << "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>" << endl;
  cout << "This is free software: you are free to change and redistribute it." << endl;
  cout << "There is NO WARRANTY, to the extent permitted by law." << endl;
}

int
parsePackages (AST_StringList imports, MMO_CompileFlags flags, bool recompile)
{
  int r = 0;
  MMO_CompileFlags fl = newMMO_CompileFlags ();
  AST_StringListIterator it;
  foreach(it,imports)
    {
      string i = *current_element(it);
      string p = Util::getInstance ()->packagePath (i, flags);
      flags->addObject (
	  p + SLASH + Util::getInstance ()->packageName (i) + ".c");
      if (!Util::getInstance ()->searchCompiledPackage (i, flags) || recompile)
	{
	  string fileName = p + SLASH + i + ".mo";
	  AST_StoredDefinition sd = NULL;
	  sd = parseFile (fileName, &r);
	  Error::getInstance ()->setFile (fileName);
	  if (r == 0)
	    {
	      AST_MicroModelica mmo = newAST_MicroModelica (fileName);
	      r = mmo->apply (sd);
	      if (r == 0)
		{
		  fl->setOutputFile (p + SLASH + i);
		  fl->setPath (p);
		  parsePackages (sd->imports (), fl, recompile);
		  list<string> objects = fl->objects ();
		  for (list<string>::iterator it = objects.begin ();
		      it != objects.end (); it++)
		    {
		      flags->addObject (*it);
		    }
		  Error::getInstance ()->setFile (fileName);
		  Util::getInstance ()->setCompileFlags (fl);
		  MMO_MicroModelicaIR ir = newMMO_MicroModelicaIR (fileName);
		  r = ir->apply (sd);
		  if (r == 0)
		    {
		      MMO_Generator gen = newMMO_Generator (
			  ir->storedDefinition (), fl);
		      r = gen->generate ();
		      delete gen;
		    }
		  delete ir;
		}
	      delete mmo;
	    }
	  else
	    {
	      delete sd;
	      delete fl;
	      return (r);
	    }
	  delete sd;
	}
      else
	{
	  Util::getInstance ()->setCompileFlags (flags);
	  MMO_PackageData pd = Util::getInstance ()->readPackage (i);
	  if (pd == NULL)
	    {
	      Error::getInstance ()->add (0, EM_CANT_OPEN_FILE, ER_Error,
					  "%s.moo", i.c_str ());
	      delete fl;
	      return (-1);
	    }
	  MMO_ImportTable objects = pd->objects ();
	  for (string it = objects->begin (); !objects->end ();
	      it = objects->next ())
	    {
	      flags->addObject (it);
	    }
	}
    }
  delete fl;
  return (r);
}

int
main (int argc, char ** argv)
{
  int r = 0;
  int opt;
  extern char *optarg;
  char strArg[128];
  bool recompile = false;
  bool settings = false;
  MMO_CompileFlags flags = newMMO_CompileFlags ();
  while (1)
    {
      static struct option long_options[] =
	{
	  { "version", no_argument, 0, 'v' },
	  { "help", no_argument, 0, 'h' },
	  { "include", required_argument, 0, 'i' },
	  { "external-structure-file", required_argument, 0, 'e' },
	  { "force", no_argument, 0, 'f' },
	  { "settings-only", no_argument, 0, 's' },
	  { "optimize", no_argument, 0, 'O' },
	  { "parallel", no_argument, 0, 'p' },
	  { "debug", required_argument, 0, 'd' },
	  { "output", required_argument, 0, 'o' },
	  { 0, 0, 0, 0 } };
      int option_index = 0;
      opt = getopt_long (argc, argv, "vhmfsOpi:d:o:", long_options,
			 &option_index);
      if (opt == EOF)
	break;
      switch (opt)
	{
	case 'v':
	  version ();
	  exit(0);
	case 'h':
	  usage ();
	  exit(0);
	case 'm':
	  flags->setIncidenceMatrices (true);
	  break;
	case 'd':
	  sscanf (optarg, "%s", strArg);
	  flags->setDebug (strArg);
	  break;
	case 'o':
	  flags->setOutputFile (optarg);
	  break;
	case 'i':
	  flags->addLibraryPath (optarg);
	  break;
	case 'p':
	  flags->setParallel (true);
	  break;
	case 'e':
	  flags->setExternalStructureFile (true);
	  break;
	case 'f':
	  recompile = true;
	  break;
	case 's':
	  settings = true;
	  break;
	case 'O':
	  flags->setOptimizeQSS (true);
	  break;
	case '?':
	  usage ();
	  exit (-1);
	  break;
	default:
	  abort ();
	}
    }
  string pack = Util::getInstance ()->environmentVariable ("MMOC_PACKAGES");
  if (!pack.empty ())
    {
      flags->addLibraryPath (pack);
    }
  AST_StoredDefinition sd;
  string fileName;
  if (argv[optind] != NULL)
    {
      fileName = argv[optind];
      string path = Util::getInstance()->getFilePath(fileName);
      flags->setPath (path);
      sd = parseFile (fileName, &r);
      Error::getInstance ()->setFile (fileName);
      if (r == 0)
	{
	  AST_MicroModelica mmo = newAST_MicroModelica (fileName);
	  r = mmo->apply (sd);
	  if (r == 0)
	    {
	      if (settings)
		{
		  MMO_Settings set = newMMO_Settings (fileName);
		  set->apply (sd);
		  MMO_Files sc = newMMO_Files (fileName, flags);
		  sc->settings (set->annotations ());
		  delete set;
		  delete sc;
		  return (0);
		}
	      int res = parsePackages (sd->imports (), flags, recompile);
	      if (res != 0)
		{
		  Error::getInstance ()->show ();
		  cout << "Exit code: " << res << endl;
		  delete flags;
		  delete mmo;
		  return (res);
		}
	      Util::getInstance ()->setCompileFlags (flags);
	      Error::getInstance ()->setFile (fileName);
	      MMO_MicroModelicaIR ir = newMMO_MicroModelicaIR (fileName);
	      r = ir->apply (sd);
	      if (r == 0)
		{
		  MMO_Generator gen = newMMO_Generator (ir->storedDefinition (),
							flags);
		  r = gen->generate ();
		  delete gen;
		}
	      delete ir;
	    }
	  delete mmo;
	}
    }
  delete flags;
  Error::getInstance ()->show ();
  cout << "Exit code: " << r << endl;
  return (r);
}
