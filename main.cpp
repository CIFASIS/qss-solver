/*****************************************************************************

 This file is part of QSS Solver.

 QSS Solver is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 QSS Solver is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with QSS Solver.  If not, see <http://www.gnu.org/licenses/>.

 ******************************************************************************/

#include <getopt.h>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <list>
#include <string>

#include "ast/ast_types.h"
#include "ast/stored_definition.h"
#include "generator/files.h"
#include "generator/generator.h"
#include "generator/generator_types.h"
#include "ir/mmo_ir.h"
#include "ir/mmo_model_checker.h"
#include "ir/mmo_settings.h"
#include "ir/mmo_types.h"
#include "ir/mmo_util.h"
#include "parser/parse.h"
#include "util/compile_flags.h"
#include "util/error.h"
#include "util/symbol_table.h"
#include "util/util.h"
#include "util/util_types.h"

using namespace std;

void
usage ()
{
    cout << "Usage mmoc [options] file" << endl;
    cout << "Compile MicroModelica files and generate a C file that implements a model suitable for the Stand--Alone QSS solver." << endl;
    cout << endl;
    cout << "-d <flag>, --debug <flag>" << endl;
    cout << "                Sets the simulation debug <flag>, the debug information is written in the log file generated " << endl;
    cout << "                by the Stand--Alone QSS solver and is an OR combination of the following possibilities: " << endl;
    cout << "                    SD_DBG_All: Enable all the debug flags" << endl;
    cout << "                    SD_DBG_Dt: Log dt parameter changes in parallel simulations" << endl;
    cout << "                    SD_DBG_ExternalEvent: Output step information for each external event in parallel simulations" << endl;
    cout << "                    SD_DBG_InitValues: Output the simulation initialization, including initial state and state derivatives values"
            << endl;
    cout << "                    SD_DBG_Memory: Output memory footprint" << endl;
    cout << "                    SD_DBG_Synchronize: Output synchronization information in parallel simulations" << endl;
    cout << "                    SD_DBG_StepInfo: Output for each simulation step:" << endl;
    cout << "                       ** The step time" << endl;
    cout << "                       ** The type and index of the variable that changes" << endl;
    cout << "                    SD_DBG_VarChanges: Output the model's state variable changes and the number of handler executions" << endl;
    cout << "                                       for each event defined in the model" << endl;
    cout << "                    SD_DBG_WaitFor: Output synchronization information in parallel simulations" << endl;
    cout << "                    SD_DBG_Weights: Save the output values generated by the SD_DBG_VarChanges into a binary file" << endl;
    cout << "-e, --external-structure-file <file>" << endl;
    cout << "                Read model incidence matrices from <file>." << endl;
    cout << "-f, --force " << endl;
    cout << "                Force external package compilation." << endl;
    cout << "-h, --help      Display this information and exit" << endl;
    cout << "-i <path>, --include <path>" << endl;
    cout << "                Include <path> in the library path search.          " << endl;
    cout << "-o <file>, --output <file>" << endl;
    cout << "                Sets the output to <file>" << endl;
    cout << "-O, --optimize" << endl;
    cout << "                Try to avoid the calculation of the next time of change for influenced variables in QSS algorithms (experimental)"
            << endl;
    cout << "-p, --parallel" << endl;
    cout << "                Generate code for parallel simulation." << endl;
    cout << "-s, --settings-only" << endl;
    cout << "                Generate only the settings (.ini) file." << endl;
    cout << "-v, --version   Display version information and exit" << endl;
    cout << endl;
    cout << "Report bugs to: joaquin.f.fernandez@gmail.com" << endl;
    cout << "MicroModelica C Compiler home page: https://sourceforge.net/p/qssengine/" << endl;
}

void
version ()
{
    cout << "MicroModelica C Compiler 3.1" << endl;
    cout << "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>" << endl;
    cout << "This is free software: you are free to change and redistribute it." << endl;
    cout << "There is NO WARRANTY, to the extent permitted by law." << endl;
}

int
parsePackages (AST_StringList imports, MMO_CompileFlags flags, bool recompile)
{
    int r = 0;
    MMO_CompileFlags fl = newMMO_CompileFlags ();
    AST_StringListIterator it;
    foreach(it,imports)
    {
        string i = *current_element(it);
        string p = Util::getInstance ()->packagePath (i, flags);
        flags->addObject (p + SLASH + Util::getInstance ()->packageName (i) + ".c");
        if (!Util::getInstance ()->searchCompiledPackage (i, flags) || recompile)
        {
            string fileName = p + SLASH + i + ".mo";
            AST_StoredDefinition sd = NULL;
            sd = parseFile (fileName, &r);
            Error::getInstance ()->setFile (fileName);
            if (r == 0)
            {
                AST_MicroModelica mmo = newAST_MicroModelica (fileName);
                r = mmo->apply (sd);
                if (r == 0)
                {
                    fl->setOutputFile (p + SLASH + i);
                    fl->setPath (p);
                    parsePackages (sd->imports (), fl, recompile);
                    list<string> objects = fl->objects ();
                    for (list<string>::iterator it = objects.begin (); it != objects.end (); it++)
                    {
                        flags->addObject (*it);
                    }
                    Error::getInstance ()->setFile (fileName);
                    Util::getInstance ()->setCompileFlags (fl);
                    MMO_MicroModelicaIR ir = newMMO_MicroModelicaIR (fileName);
                    r = ir->apply (sd);
                    if (r == 0)
                    {
                        MMO_Generator gen = newMMO_Generator (ir->storedDefinition (), fl);
                        r = gen->generate ();
                        delete gen;
                    }
                    delete ir;
                }
                delete mmo;
            }
            else
            {
                delete sd;
                delete fl;
                return (r);
            }
            delete sd;
        }
        else
        {
            Util::getInstance ()->setCompileFlags (flags);
            MMO_PackageData pd = Util::getInstance ()->readPackage (i);
            if (pd == NULL)
            {
                Error::getInstance ()->add (0, EM_CANT_OPEN_FILE, ER_Error, "%s.moo", i.c_str ());
                delete fl;
                return (-1);
            }
            MMO_ImportTable objects = pd->objects ();
            for (string it = objects->begin (); !objects->end (); it = objects->next ())
            {
                flags->addObject (it);
            }
        }
    }
    delete fl;
    return (r);
}

int
main (int argc, char ** argv)
{
    int r = 0;
    int opt;
    extern char *optarg;
    char strArg[128];
    bool recompile = false;
    bool settings = false;
    MMO_CompileFlags flags = newMMO_CompileFlags ();
    while (1)
    {
        static struct option long_options[] =
        {
        { "version", no_argument, 0, 'v' },
        { "help", no_argument, 0, 'h' },
        { "include", required_argument, 0, 'i' },
        { "external-structure-file", required_argument, 0, 'e' },
        { "force", no_argument, 0, 'f' },
        { "settings-only", no_argument, 0, 's' },
        { "optimize", no_argument, 0, 'O' },
        { "parallel", no_argument, 0, 'p' },
        { "debug", required_argument, 0, 'd' },
        { "output", required_argument, 0, 'o' },
        { 0, 0, 0, 0 } };
        int option_index = 0;
        opt = getopt_long (argc, argv, "vhmfsOpi:d:o:", long_options, &option_index);
        if (opt == EOF)
            break;
        switch (opt)
        {
            case 'v':
                version ();
                exit (0);
            case 'h':
                usage ();
                exit (0);
            case 'm':
                flags->setIncidenceMatrices (true);
                break;
            case 'd':
                sscanf (optarg, "%s", strArg);
                flags->setDebug (strArg);
                break;
            case 'o':
                flags->setOutputFile (optarg);
                break;
            case 'i':
                flags->addLibraryPath (optarg);
                break;
            case 'p':
                flags->setParallel (true);
                break;
            case 'e':
                flags->setExternalStructureFile (true);
                break;
            case 'f':
                recompile = true;
                break;
            case 's':
                settings = true;
                break;
            case 'O':
                flags->setOptimizeQSS (true);
                break;
            case '?':
                usage ();
                exit (-1);
                break;
            default:
                abort ();
        }
    }
    string pack = Util::getInstance ()->environmentVariable ("MMOC_PACKAGES");
    if (!pack.empty ())
    {
        flags->addLibraryPath (pack);
    }
    AST_StoredDefinition sd;
    string fileName;
    if (argv[optind] != NULL)
    {
        fileName = argv[optind];
        string path = Util::getInstance ()->getFilePath (fileName);
        flags->setPath (path);
        sd = parseFile (fileName, &r);
        Error::getInstance ()->setFile (fileName);
        if (r == 0)
        {
            AST_MicroModelica mmo = newAST_MicroModelica (fileName);
            r = mmo->apply (sd);
            if (r == 0)
            {
                if (settings)
                {
                    MMO_Settings set = newMMO_Settings (fileName);
                    set->apply (sd);
                    MMO_Files sc = newMMO_Files (fileName, flags);
                    sc->settings (set->annotations ());
                    delete set;
                    delete sc;
                    return (0);
                }
                int res = parsePackages (sd->imports (), flags, recompile);
                if (res != 0)
                {
                    Error::getInstance ()->show ();
                    cout << "Exit code: " << res << endl;
                    delete flags;
                    delete mmo;
                    return (res);
                }
                Util::getInstance ()->setCompileFlags (flags);
                Error::getInstance ()->setFile (fileName);
                MMO_MicroModelicaIR ir = newMMO_MicroModelicaIR (fileName);
                r = ir->apply (sd);
                if (r == 0)
                {
                    MMO_Generator gen = newMMO_Generator (ir->storedDefinition (), flags);
                    r = gen->generate ();
                    delete gen;
                }
                delete ir;
            }
            delete mmo;
        }
    }
    delete flags;
    Error::getInstance ()->show ();
    cout << "Exit code: " << r << endl;
    return (r);
}
